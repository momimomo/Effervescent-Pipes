import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

function getRandomValueFromArray(arr) {
  if (arr.length === 0) {
    throw new Error("Array is empty");
  }
  const randomIndex = Math.floor(Math.random() * arr.length);
  return arr[randomIndex];
}

function rotate(cube, axis, times) {
  const temp = cube.split('');
  for (let t = 0; t < times; t++) {
    let order;
    if (axis === 'x') order = [4, 5, 2, 3, 0, 1];
    else if (axis === 'y') order = [1, 0, 4, 5, 2, 3];
    else order = [2, 3, 0, 1, 4, 5];

    const newCube = new Array(6);
    for (let i = 0; i < 6; i++) {
      newCube[i] = temp[order[i]];
    }
    temp.splice(0, 6, ...newCube);
  }
  return temp.join('');
}

function getAllRotations(cube) {
  const rotations = new Set();
  for (let x = 0; x < 4; x++) {
    for (let y = 0; y < 4; y++) {
      for (let z = 0; z < 4; z++) {
        const rotatedCube = rotate(rotate(rotate(cube, 'x', x), 'y', y), 'z', z);
        rotations.add(rotatedCube);
      }
    }
  }
  return Array.from(rotations);
}

const unique3DShapes = [
    "110000",
    "010100",
    "111000",
    "111001",
    "111100",
    "111110",
    "111111",
    "000000"
];

function getAllRotations(cube) {
  const rotations = new Set();
  for (let x = 0; x < 4; x++) {
    for (let y = 0; y < 4; y++) {
      for (let z = 0; z < 4; z++) {
        const rotatedCube = rotate(rotate(rotate(cube, 'x', x), 'y', y), 'z', z);
        rotations.add(rotatedCube);
      }
    }
  }
  return Array.from(rotations);
}

function createThreeJSShape(shape) {
    const cellSize = 0.33333333;

    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });

    // Helper function to create a cube
    const createCube = (x, y, z) => {
        const geometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(x, y, z);
        return cube;
    };

    const shapeObject = new THREE.Object3D();

    if (shape === '000000') {
      return shapeObject;
    }

    // Center cube
    shapeObject.add(createCube(0, 0, 0));

    // Iterate through the shape string to add cubes accordingly
    for (let i = 0; i < 6; i++) {
        if (shape[i] === '1') {
            const x = (i === 0 || i === 1) ? cellSize * (i * 2 - 1) : 0;
            const y = (i === 2 || i === 3) ? cellSize * (i * 2 - 5) : 0;
            const z = (i === 4 || i === 5) ? cellSize * (i * 2 - 9) : 0;

            shapeObject.add(createCube(x, y, z));
        }
    }
    return shapeObject;
}

const getAllShapesVariants = (shapes) => {
  let allShapesVariants = []
  for (let shape of shapes) {
    const shapeVariants = getAllRotations(shape);
    allShapesVariants = [...allShapesVariants, ...shapeVariants]
  }
  return allShapesVariants;
}

function getCompatibleNeighbors(shape, direction, allShapes) {
  const compatibleNeighbors = [];

  allShapes.forEach((neighborShape) => {
    if (shape === neighborShape) return;

    let matchingFace;
    switch (direction) {
      case '-X':
        matchingFace = 1;
        break;
      case '+X':
        matchingFace = 0;
        break;
      case '-Y':
        matchingFace = 3;
        break;
      case '+Y':
        matchingFace = 2;
        break;
      case '-Z':
        matchingFace = 5;
        break;
      case '+Z':
        matchingFace = 4;
        break;
      default:
        throw new Error('Invalid direction');
    }

    if (shape[matchingFace] === neighborShape[matchingFace]) {
      compatibleNeighbors.push(neighborShape);
    }
  });

  return compatibleNeighbors;
}

function createGrid(n, allowedShapes) {
  const array = new Array(n);

  for (let x = 0; x < n; x++) {
    array[x] = new Array(n);

    for (let y = 0; y < n; y++) {
      array[x][y] = new Array(n);

      for (let z = 0; z < n; z++) {
        array[x][y][z] = { allowed: allowedShapes };
      }
    }
  }

  return array;
}

// only if a cell has a shape already
const reduceAllowedNeighbors = (position, grid) => {
  const [x, y, z] = position;
  const currentCell = grid[x][y][z];
  const shape = currentCell.shape;
  let neighborCell = {};
  let newAllowed = {}
  for (let i = 0; i < 6; i++) {
    switch (i) {
      case 0:
        neighborCell = grid[x - 1] && grid[x - 1][y] && grid[x - 1][y][z];
        if (neighborCell) {
          newAllowed = neighborCell.allowed.filter(i => shape[0] === i[1]);
          grid[x - 1][y][z]['allowed'] = newAllowed;
        }
        break;
      case 1:
        neighborCell = grid[x + 1] && grid[x + 1][y] && grid[x + 1][y][z];
        if (neighborCell) {
        newAllowed = neighborCell.allowed.filter(i => shape[1] === i[0]);
        grid[x + 1][y][z]['allowed'] = newAllowed;
        }
        break;
      case 2:
        neighborCell = grid[x] && grid[x][y - 1] && grid[x][y - 1][z];
        if (neighborCell) {
        newAllowed = neighborCell.allowed.filter(i => shape[2] === i[3]);
        grid[x][y - 1][z]['allowed'] = newAllowed;
        }
        break;
      case 3:
        neighborCell = grid[x] && grid[x][y + 1] && grid[x][y + 1][z];
        if (neighborCell) {
        newAllowed = neighborCell.allowed.filter(i => shape[3] === i[2]);
        grid[x][y + 1][z]['allowed'] = newAllowed;
        }
        break;
      case 4:
        neighborCell = grid[x] && grid[x][y] && grid[x][y][z - 1];
        if (neighborCell) {
        newAllowed = neighborCell.allowed.filter(i => shape[4] === i[5]);
        grid[x][y][z - 1]['allowed'] = newAllowed;
        }
        break;
      case 5:
        neighborCell = grid[x] && grid[x][y] && grid[x][y][z + 1];
        if (neighborCell) {
        newAllowed = neighborCell.allowed.filter(i => shape[5] === i[4]);
        grid[x][y][z + 1]['allowed'] = newAllowed;
        }
        break;
    }
  }
}

const findLowestEntropyCell = (grid) => {
  let lowestEntropy = 31; // 1 larger than number of all possible unique shapes (31 unique rotations of initial 7)
  let lowestEntropyCell;
  for (let x = 0; x < grid.length; x++) {
    for (let y = 0; y < grid.length; y++) {
      for (let z = 0; z < grid.length; z++) {
        const target = grid[x][y][z];
        const isCollapsed = target.shape;
        if (!isCollapsed) {
          const numberOfShapes = target.allowed.length
          if (numberOfShapes < lowestEntropy) {
            lowestEntropy = numberOfShapes;
            lowestEntropyCell = [x,y,z];
          } 
        }
      }
    }
  }
  if (!lowestEntropyCell) {
    return false
  }
  return lowestEntropyCell;
}




const allShapesVariants = getAllShapesVariants(unique3DShapes);

let grid = createGrid(9, allShapesVariants);

const exampleNeighbors = getCompatibleNeighbors(allShapesVariants[0], '-X', allShapesVariants)


console.log('allShapesVariants', allShapesVariants)
console.log('exampleNeighbors', exampleNeighbors)

console.log('grid', grid)

grid[4][4][4] = {shape: '111111', allowed: []}

reduceAllowedNeighbors([4,4,4], grid)

console.log('grid after reduction', grid)



for (let i=0;i<1024;i++) {
  const lowestEntropyCell = findLowestEntropyCell(grid)
  if (lowestEntropyCell) {
    const [x,y,z] = lowestEntropyCell;
    grid[x][y][z] = {
      shape: getRandomValueFromArray(grid[x][y][z]['allowed']),
      allowed: []
    }
    reduceAllowedNeighbors([x,y,z], grid)
  }
  
}

console.log('grid after 256 find', grid)

function createScene() {
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  const renderer = new THREE.WebGLRenderer();

  controls = new OrbitControls(camera, renderer.domElement);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  camera.position.z = 26;
  camera.position.x = 12;
  camera.position.y =   2;

  // let ix = -2
  // let iy = -2
  //   for (let shape of shapes3D) {
  //     scene.add(shape)
  //     shape.position.set(ix, iy, 0)
  //     ix += 1
  //     if (ix ===  2) {
  //       ix = -2
  //       iy += 1
  //     }
  //   }


  function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  
  async function delayedLoop() {
    for (let x = 0; x < grid.length; x++) {
      for (let y = 0; y < grid.length; y++) {
        for (let z = 0; z < grid.length; z++) {
          const t = grid[x][y][z].shape;
          if (t) {
            const obj = createThreeJSShape(t);
            scene.add(obj);
            obj.position.set(x, y, z);
          }
  
          // Add the delay here
          await sleep(10);
        }
      }
    }
  }



  function animate() {
    controls.update();
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }

  animate();
  delayedLoop()
}

createScene();
